package fxnclient

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"net/http"
	"testing"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// mockRoundTripper is a mock implementation of http.RoundTripper for testing.
type mockRoundTripper struct {
	roundTrip func(req *http.Request) (*http.Response, error)
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	return m.roundTrip(req)
}

func TestNewFxnClient(t *testing.T) {
	privateKey, err := crypto.GenerateKey()
	require.NoError(t, err)
	privateKeyHex := hex.EncodeToString(crypto.FromECDSA(privateKey))

	t.Run("valid private key", func(t *testing.T) {
		client, err := NewFxnClient(privateKeyHex, &http.Client{})
		require.NoError(t, err)
		assert.NotNil(t, client)
		assert.NotNil(t, client.privateKey)
		assert.NotNil(t, client.client)
	})

	t.Run("invalid private key", func(t *testing.T) {
		client, err := NewFxnClient("invalid-key", &http.Client{})
		require.Error(t, err)
		assert.Nil(t, client)
	})
}

func TestSignRequest(t *testing.T) {
	privateKey, err := crypto.GenerateKey()
	require.NoError(t, err)
	privateKeyHex := hex.EncodeToString(crypto.FromECDSA(privateKey))
	address := crypto.PubkeyToAddress(privateKey.PublicKey).Hex()

	client, err := NewFxnClient(privateKeyHex, &http.Client{})
	require.NoError(t, err)

	req, err := http.NewRequest("POST", "http://localhost", bytes.NewReader([]byte("test body")))
	require.NoError(t, err)

	timestamp := "1234567890"
	nonce := "test-nonce"
	body := []byte("test body")

	err = client.SignRequest(req, body, timestamp, nonce)
	require.NoError(t, err)

	// Test case for crypto.Sign failing
	client.privateKey, err = crypto.GenerateKey()
	require.NoError(t, err)
	client.privateKey.D.SetInt64(0)
	err = client.SignRequest(req, body, timestamp, nonce)
	require.Error(t, err)

	assert.Equal(t, "application/json", req.Header.Get("Content-Type"))
	assert.Equal(t, address, req.Header.Get("X-Address"))
	assert.Equal(t, timestamp, req.Header.Get("X-Timestamp"))
	assert.Equal(t, nonce, req.Header.Get("X-Nonce"))

	signature, err := hex.DecodeString(req.Header.Get("X-Signature"))
	require.NoError(t, err)

	bodyHash := sha256.Sum256(body)
	messageStr := fmt.Sprintf("%x.%s.%s", bodyHash, timestamp, nonce)
	messageHash := EIP191Hash(messageStr)

	valid, err := VerifySignature(signature, messageHash, address)
	require.NoError(t, err)
	assert.True(t, valid)
}

func TestSendRequest(t *testing.T) {
	privateKey, err := crypto.GenerateKey()
	require.NoError(t, err)
	privateKeyHex := hex.EncodeToString(crypto.FromECDSA(privateKey))

	mockClient := &http.Client{
		Transport: &mockRoundTripper{
			roundTrip: func(req *http.Request) (*http.Response, error) {
				// Check that the request is signed
				assert.NotEmpty(t, req.Header.Get("X-Address"))
				assert.NotEmpty(t, req.Header.Get("X-Timestamp"))
				assert.NotEmpty(t, req.Header.Get("X-Nonce"))
				assert.NotEmpty(t, req.Header.Get("X-Signature"))

				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       io.NopCloser(bytes.NewReader([]byte("OK"))),
				}, nil
			},
		},
	}

	client, err := NewFxnClient(privateKeyHex, mockClient)
	require.NoError(t, err)

	resp, err := client.SendRequest("POST", "http://localhost", []byte("test body"))
	require.NoError(t, err)
	defer resp.Body.Close()

	assert.Equal(t, http.StatusOK, resp.StatusCode)
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	assert.Equal(t, "OK", string(body))

	// Test case for http.NewRequest failing
	_, err = client.SendRequest(" \x7f", "http://localhost", []byte("test body"))
	require.Error(t, err)

	// Test case for SignRequest failing
	client.privateKey.D.SetInt64(0)
	_, err = client.SendRequest("POST", "http://localhost", []byte("test body"))
	require.Error(t, err)
}

func TestEIP191Hash(t *testing.T) {
	message := "test message"
	// This is the expected hash for the string "test message" with the EIP-191 prefix.
	// It was generated by running the code and capturing the output.
	expectedHash := "0x3e2d111c8c52a5ef0ba64fe4d85e32a5153032367ec44aaae0a4e2d1bfb9bebd"
	hash := EIP191Hash(message)
	assert.Equal(t, expectedHash, "0x"+hex.EncodeToString(hash))
}

func TestVerifySignature(t *testing.T) {
	privateKey, err := crypto.GenerateKey()
	require.NoError(t, err)

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	require.True(t, ok)

	address := crypto.PubkeyToAddress(*publicKeyECDSA).Hex()
	message := []byte("test message")
	hash := EIP191Hash(string(message))

	signature, err := crypto.Sign(hash, privateKey)
	require.NoError(t, err)
	signature[64] += 27 // for EIP-155 compatibility

	t.Run("valid signature", func(t *testing.T) {
		valid, err := VerifySignature(signature, hash, address)
		require.NoError(t, err)
		assert.True(t, valid)
	})

	t.Run("invalid signature", func(t *testing.T) {
		invalidSig := make([]byte, len(signature))
		copy(invalidSig, signature)
		invalidSig[0]++ // Modify the signature to make it invalid
		valid, _ := VerifySignature(invalidSig, hash, address)
		assert.False(t, valid)
	})

	t.Run("wrong address", func(t *testing.T) {
		wrongAddress := "0x0000000000000000000000000000000000000000"
		valid, err := VerifySignature(signature, hash, wrongAddress)
		require.NoError(t, err)
		assert.False(t, valid)
	})

	t.Run("short signature", func(t *testing.T) {
		shortSig := []byte{1, 2, 3}
		valid, err := VerifySignature(shortSig, hash, address)
		require.Error(t, err)
		assert.False(t, valid)
	})
}
